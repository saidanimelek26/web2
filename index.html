<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Linux ADK Web</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      content: [],
      theme: { extend: {} },
      plugins: [],
    };
  </script>
  <style>
    body {
      background-color: #f3f4f6;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.18.9/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const defaultAccessory = {
      device: "18d1:4e42",
      manufacturer: "Google, Inc.",
      model: "AccessoryChat",
      description: "Sample Program",
      version: "1.0",
      url: "https://github.com/gibsson",
      serial: "0000000012345678",
    };

    const AOA_ACCESSORY_VID = 0x18D1;
    const AOA_ACCESSORY_PID = 0x2D00;
    const AOA_ACCESSORY_ADB_PID = 0x2D01;
    const AOA_AUDIO_PID = 0x2D02;
    const AOA_AUDIO_ADB_PID = 0x2D03;
    const AOA_ACCESSORY_AUDIO_PID = 0x2D04;
    const AOA_ACCESSORY_AUDIO_ADB_PID = 0x2D05;

    const AOA_GET_PROTOCOL = 51;
    const AOA_SEND_IDENT = 52;
    const AOA_START_ACCESSORY = 53;
    const AOA_AUDIO_SUPPORT = 58;

    const AOA_STRING_MAN_ID = 0;
    const AOA_STRING_MOD_ID = 1;
    const AOA_STRING_DSC_ID = 2;
    const AOA_STRING_VER_ID = 3;
    const AOA_STRING_URL_ID = 4;
    const AOA_STRING_SER_ID = 5;

    function App() {
      const [accessory, setAccessory] = React.useState(defaultAccessory);
      const [logs, setLogs] = React.useState([]);
      const [device, setDevice] = React.useState(null);
      const [aoaVersion, setAoaVersion] = React.useState(null);
      const [isConnected, setIsConnected] = React.useState(false);

      const addLog = (message) => {
        setLogs((prev) => [...prev, message]);
      };

      const handleInputChange = (e) => {
        const { name, value } = e.target;
        setAccessory((prev) => ({ ...prev, [name]: value }));
      };

      const connectDevice = async () => {
        if (!navigator.usb) {
          addLog("WebUSB is not supported in this browser. Using mock data.");
          simulateDeviceConnection();
          return;
        }

        try {
          const device = await navigator.usb.requestDevice({
            filters: [{ vendorId: AOA_ACCESSORY_VID }],
          });
          await device.open();
          setDevice(device);
          addLog(`Connected to device: ${device.productName} (VID: ${device.vendorId}, PID: ${device.productId})`);
          setIsConnected(true);
          await initializeAccessory(device);
        } catch (error) {
          addLog(`Error connecting to device: ${error.message}`);
        }
      };

      const simulateDeviceConnection = () => {
        setDevice({ productName: "Mock Accessory", vendorId: AOA_ACCESSORY_VID, productId: AOA_ACCESSORY_PID });
        setIsConnected(true);
        addLog("Simulating device connection with mock data.");
        initializeAccessory({ mock: true });
      };

      const initializeAccessory = async (device) => {
        try {
          addLog("Checking if device supports AOA protocol...");
          const aoaVersion = await getAoaProtocol(device);
          setAoaVersion(aoaVersion);
          addLog(`Device supports AOA ${aoaVersion}.0`);

          if (aoaVersion >= 2) {
            addLog("Requesting audio support...");
            await requestAudioSupport(device);
          }

          addLog("Sending identification to the device...");
          await sendIdentification(device, accessory);

          addLog("Turning device into Accessory mode...");
          await startAccessoryMode(device);

          addLog("Device initialized successfully!");
          startDataSnooping(device);
        } catch (error) {
          addLog(`Initialization failed: ${error.message}`);
        }
      };

      const getAoaProtocol = async (device) => {
        if (device.mock) return 2;
        const result = await device.controlTransferIn({
          requestType: "vendor",
          recipient: "device",
          request: AOA_GET_PROTOCOL,
          value: 0,
          index: 0,
        }, 2);
        if (result.status === "ok") {
          const buffer = new Uint8Array(result.data.buffer);
          return (buffer[1] << 8) | buffer[0];
        }
        throw new Error("Failed to get AOA protocol");
      };

      const sendIdentification = async (device, acc) => {
        const fields = [
          { id: AOA_STRING_MAN_ID, value: acc.manufacturer },
          { id: AOA_STRING_MOD_ID, value: acc.model },
          { id: AOA_STRING_DSC_ID, value: acc.description },
          { id: AOA_STRING_VER_ID, value: acc.version },
          { id: AOA_STRING_URL_ID, value: acc.url },
          { id: AOA_STRING_SER_ID, value: acc.serial },
        ];

        for (const field of fields) {
          if (field.value) {
            addLog(`Sending ${field.id === AOA_STRING_MAN_ID ? "manufacturer" : field.id === AOA_STRING_MOD_ID ? "model" : field.id === AOA_STRING_DSC_ID ? "description" : field.id === AOA_STRING_VER_ID ? "version" : field.id === AOA_STRING_URL_ID ? "url" : "serial"}: ${field.value}`);
            if (!device.mock) {
              const data = new TextEncoder().encode(field.value + "\0");
              await device.controlTransferOut({
                requestType: "vendor",
                recipient: "device",
                request: AOA_SEND_IDENT,
                value: 0,
                index: field.id,
              }, data);
            }
          }
        }
      };

      const requestAudioSupport = async (device) => {
        if (device.mock) return;
        await device.controlTransferOut({
          requestType: "vendor",
          recipient: "device",
          request: AOA_AUDIO_SUPPORT,
          value: 1,
          index: 0,
        });
      };

      const startAccessoryMode = async (device) => {
        if (device.mock) return;
        await device.controlTransferOut({
          requestType: "vendor",
          recipient: "device",
          request: AOA_START_ACCESSORY,
          value: 0,
          index: 0,
        });
      };

      const startDataSnooping = async (device) => {
        if (device.mock) {
          setInterval(() => {
            const mockData = new Uint8Array([0x41, 0x42, 0x43, 0x44]);
            addLog(`Received ${mockData.length} bytes: ${Array.from(mockData).map(b => `0x${b.toString(16).padStart(2, "0")}`).join(" ")}`);
          }, 2000);
          return;
        }

        try {
          await device.selectConfiguration(1);
          await device.claimInterface(0);
          while (true) {
            const result = await device.transferIn(0x81, 512);
            if (result.status === "ok") {
              const data = new Uint8Array(result.data.buffer);
              addLog(`Received ${data.length} bytes: ${Array.from(data).map(b => `0x${b.toString(16).padStart(2, "0")}`).join(" ")}`);
            } else {
              addLog("Transfer error");
            }
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        } catch (error) {
          addLog(`Snooping error: ${error.message}`);
        }
      };

      const disconnectDevice = async () => {
        if (device && !device.mock) {
          try {
            await device.close();
            addLog("Device disconnected");
          } catch (error) {
            addLog(`Error disconnecting: ${error.message}`);
          }
        }
        setDevice(null);
        setIsConnected(false);
        setAoaVersion(null);
      };

      return (
        <div className="bg-white p-6 rounded-lg shadow-lg">
          <h1 className="text-2xl font-bold mb-4">Linux ADK Web</h1>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            {Object.keys(defaultAccessory).map((key) => (
              <div key={key} className="flex flex-col">
                <label className="font-semibold capitalize">{key}</label>
                <input
                  type="text"
                  name={key}
                  value={accessory[key]}
                  onChange={handleInputChange}
                  className="border p-2 rounded"
                  disabled={isConnected}
                />
              </div>
            ))}
          </div>
          <div className="flex space-x-4 mb-4">
            <button
              onClick={connectDevice}
              disabled={isConnected}
              className="bg-blue-500 text-white p-2 rounded disabled:bg-gray-400"
            >
              Connect Device
            </button>
            <button
              onClick={disconnectDevice}
              disabled={!isConnected}
              className="bg-red-500 text-white p-2 rounded disabled:bg-gray-400"
            >
              Disconnect
            </button>
          </div>
          <div className="bg-gray-800 text-white p-4 rounded h-64 overflow-y-auto">
            <h2 className="text-lg font-semibold mb-2">Logs</h2>
            {logs.map((log, index) => (
              <p key={index} className="font-mono text-sm">{log}</p>
            ))}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>